"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryService = void 0;
const base_delivery_query_service_1 = require("./base-delivery-query.service");
class QueryService extends base_delivery_query_service_1.BaseDeliveryQueryService {
    constructor(config, httpService, sdkInfo, mappingService) {
        super(config, httpService, sdkInfo, mappingService);
    }
    /**
     * Gets single item from given url
     * @param url Url used to get single item
     * @param queryConfig Query configuration
     */
    getSingleItemAsync(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.viewContentItemResponse(response.data), response);
        });
    }
    /**
     * Gets single feed response. Might not contain all items in your environment.
     * @param url Url
     * @param queryConfig Query configuration
     */
    getItemsFeed(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.itemsFeedResponse(response.data), response);
        });
    }
    /**
     * Gets single used in response. Might not contain all used in references.
     * @param url Url
     * @param queryConfig Query configuration
     */
    getUsedIn(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.usedInResponse(response.data), response);
        });
    }
    /**
     * Gets multiple items from given url
     * @param url Url used to get multiple items
     * @param queryConfig Query configuration
     */
    getMultipleItems(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.listContentItemsResponse(response.data), response);
        });
    }
    /**
     * Gets single content type from given url
     * @param url Url used to get single type
     * @param queryConfig Query configuration
     */
    getSingleType(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.viewContentTypeResponse(response.data), response);
        });
    }
    /**
     * Gets multiple content types from given url
     * @param url Url used to get multiple types
     * @param queryConfig Query configuration
     */
    getMultipleTypes(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.listContentTypesResponse(response.data), response);
        });
    }
    /**
     * Initializes synchronization of changes in content items based on the specified parameters. After the initialization,
     * you'll get an X-Continuation token in the response.
     * Use the token to synchronize changes in the content items matching the initialization criteria.
     * @param url Url
     * @param queryConfig Query configuration
     */
    initializeSync(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.postResponseAsync(url, {}, queryConfig);
            return this.mapNetworkResponse(this.mappingService.initializeContentSync(response.data), response);
        });
    }
    /**
     * Retrieve a list of delta updates to recently changed content items in the specified environment.
     * The types of items you get is determined by the X-Continuation token you use.
     * @param url Url used to get multiple types
     * @param queryConfig Query configuration
     */
    syncChanges(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.syncChanges(response.data), response);
        });
    }
    /**
     * Gets languages
     * @param url Url
     * @param queryConfig Query configuration
     */
    getLanguages(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.listLanguagesResponse(response.data), response);
        });
    }
    /**
     * Gets single taxonomy from given url
     * @param url Url used to get single taxonomy
     * @param queryConfig Query configuration
     */
    getTaxonomy(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.viewTaxonomyResponse(response.data), response);
        });
    }
    /**
     * Gets multiple taxonomies from given url
     * @param url Url used to get multiple taxonomies
     * @param queryConfig Query configuration
     */
    getTaxonomies(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.listTaxonomiesResponse(response.data), response);
        });
    }
    /**
     * Gets single content type element from given url
     * @param url Url used to get single content type element
     * @param queryConfig Query configuration
     */
    getElementAsync(url, queryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.getResponseAsync(url, queryConfig);
            return this.mapNetworkResponse(this.mappingService.viewContentTypeElementResponse(response.data), response);
        });
    }
    getListAllResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = yield this.getListAllResponseInternalAsync({
                page: data.page,
                resolvedResponses: [],
                getResponse: data.getResponse,
                nextPageUrl: undefined,
                continuationToken: undefined,
                listQueryConfig: data.listQueryConfig
            });
            return data.allResponseFactory(responses.reduce((prev, current) => {
                prev.push(...current.data.items);
                return prev;
            }, []), responses);
        });
    }
    getListAllResponseInternalAsync(data) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = data.listQueryConfig) === null || _a === void 0 ? void 0 : _a.pages) {
                if (data.page > data.listQueryConfig.pages) {
                    // page limit reached, return result
                    return data.resolvedResponses;
                }
            }
            const response = yield data.getResponse(data.nextPageUrl, data.continuationToken);
            if ((_b = data.listQueryConfig) === null || _b === void 0 ? void 0 : _b.delayBetweenRequests) {
                yield this.sleep(data.listQueryConfig.delayBetweenRequests);
            }
            data.resolvedResponses.push(response);
            if ((_c = data.listQueryConfig) === null || _c === void 0 ? void 0 : _c.responseFetched) {
                data.listQueryConfig.responseFetched(response, data.nextPageUrl, data.continuationToken);
            }
            const nextPage = (_d = response.data.pagination) === null || _d === void 0 ? void 0 : _d.nextPage;
            const continuationToken = response.xContinuationToken;
            if (nextPage || continuationToken) {
                // recursively fetch next page data
                return yield this.getListAllResponseInternalAsync({
                    page: data.page + 1,
                    nextPageUrl: nextPage,
                    continuationToken: continuationToken,
                    listQueryConfig: data.listQueryConfig,
                    getResponse: data.getResponse,
                    resolvedResponses: data.resolvedResponses
                });
            }
            return data.resolvedResponses;
        });
    }
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
}
exports.QueryService = QueryService;
//# sourceMappingURL=delivery-query.service.js.map