import { IDeliveryClientConfig } from '../../config';
import { IGroupedNetworkResponse, IKontentListAllResponse, IKontentListResponse, IDeliveryNetworkResponse, IListAllQueryConfig, IQueryConfig, IContentItem, ClientTypes, IUsedInItemRecord, IContentType, ITaxonomyGroup, IContentItemDelta, ILanguage } from '../../models';
import { QueryService } from '../../services';
import { BaseQuery } from './base-query.class';
type ListingRecord<TClientTypes extends ClientTypes> = IContentItem | IContentItemDelta | IUsedInItemRecord<TClientTypes> | IContentType<TClientTypes['contentTypeCodenames']> | ILanguage<TClientTypes['languageCodenames']> | ITaxonomyGroup<TClientTypes['taxonomyCodenames']>;
export declare abstract class BaseListingQuery<TClientTypes extends ClientTypes, TRecord extends ListingRecord<TClientTypes>, TResponse extends IKontentListResponse, TAllResponse extends IKontentListAllResponse, TQueryConfig extends IQueryConfig, TContract> extends BaseQuery<TClientTypes, TResponse, TQueryConfig, TContract> {
    protected config: IDeliveryClientConfig;
    protected queryService: QueryService<TClientTypes>;
    constructor(config: IDeliveryClientConfig, queryService: QueryService<TClientTypes>);
    /**
     * Sets continuation token header
     */
    withContinuationToken(token: string): this;
    /**
     * Query to get all items. Uses paging data and may execute multiple HTTP requests depending on number of items
     */
    toAllPromise(queryAllConfig?: IListAllQueryConfig<TResponse, TContract>): Promise<IGroupedNetworkResponse<TAllResponse>>;
    protected abstract allResponseFactory(items: TRecord[], responses: IDeliveryNetworkResponse<TResponse, TContract>[]): TAllResponse;
}
export {};
