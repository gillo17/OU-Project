import { SyncMapper, GenericElementMapper, ItemMapper, LanguageMapper, TaxonomyMapper, TypeMapper, UsedInMapper } from '../mappers';
export class MappingService {
    constructor(config) {
        this.config = config;
        this.typeMapper = new TypeMapper();
        this.languageMapper = new LanguageMapper();
        this.itemMapper = new ItemMapper(config);
        this.taxonomyMapper = new TaxonomyMapper();
        this.usedInMapper = new UsedInMapper();
        this.genericElementMapper = new GenericElementMapper();
        this.syncMapper = new SyncMapper();
    }
    usedInResponse(data) {
        return {
            items: data.items.map((m) => this.usedInMapper.mapUsedInItem(m))
        };
    }
    /**
     * Gets response for list of languages
     * @param data Response data
     */
    listLanguagesResponse(data) {
        return {
            items: this.languageMapper.mapMultipleLanguages(data),
            pagination: this.mapPagination(data.pagination)
        };
    }
    /**
     * Gets response for getting a multiple type
     * @param data Response data
     */
    listContentTypesResponse(data) {
        return {
            items: this.typeMapper.mapMultipleTypes(data),
            pagination: this.mapPagination(data.pagination)
        };
    }
    /**
     * Gets response for single type
     * @param data Response data
     * @param options Options
     */
    viewContentTypeResponse(data) {
        return {
            type: this.typeMapper.mapSingleType(data)
        };
    }
    itemsFeedResponse(data) {
        const itemsResult = this.itemMapper.mapItems({
            linkedItems: Object.values(data.modular_content),
            mainItems: data.items
        });
        return {
            items: itemsResult.items,
            linkedItems: itemsResult.linkedItems
        };
    }
    /**
     * Gets response for getting single item
     * @param data Response data
     * @param queryConfig Query configuration
     */
    viewContentItemResponse(data) {
        const itemResult = this.itemMapper.mapSingleItemFromResponse(data);
        return {
            item: itemResult.item,
            linkedItems: itemResult.linkedItems
        };
    }
    /**
     * Gets response for getting multiple items
     * @param data Response data
     * @param queryConfig Query configuration
     */
    listContentItemsResponse(data) {
        const itemsResult = this.itemMapper.mapMultipleItemsFromResponse(data);
        return {
            items: itemsResult.items,
            pagination: this.mapPagination(data.pagination),
            linkedItems: itemsResult.linkedItems
        };
    }
    /**
     * Gets response for getting single taxonomy item
     * @param data Response data
     */
    viewTaxonomyResponse(data) {
        return {
            taxonomy: this.taxonomyMapper.mapTaxonomy(data.system, data.terms)
        };
    }
    /**
     * Gets response for getting multiples taxonomies
     * @param data Response data
     */
    listTaxonomiesResponse(data) {
        return {
            items: this.taxonomyMapper.mapTaxonomies(data.taxonomies),
            pagination: this.mapPagination(data.pagination)
        };
    }
    /**
     * Gets response for getting single content type element
     * @param data Response data
     */
    viewContentTypeElementResponse(data) {
        return this.genericElementMapper.mapElement(data);
    }
    initializeContentSync(data) {
        return {
            items: data.items.map((m) => this.syncMapper.mapContentItemDelta(m))
        };
    }
    syncChanges(data) {
        return {
            items: data.items.map((m) => this.syncMapper.mapContentItemDelta(m))
        };
    }
    mapPagination(paginationContract) {
        var _a;
        return {
            skip: paginationContract.skip,
            count: paginationContract.count,
            limit: paginationContract.limit,
            nextPage: paginationContract.next_page,
            totalCount: (_a = paginationContract.total_count) !== null && _a !== void 0 ? _a : null
        };
    }
}
//# sourceMappingURL=mapping.service.js.map